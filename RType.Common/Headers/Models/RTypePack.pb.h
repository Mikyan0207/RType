// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RTypePack.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_RTypePack_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_RTypePack_2eproto

#include <limits>
#include <string>

#include <RType.Common.hpp>
#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_RTypePack_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_RTypePack_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_RTypePack_2eproto;
namespace RType {
class LobbyPacket;
class LobbyPacketDefaultTypeInternal;
extern LobbyPacketDefaultTypeInternal _LobbyPacket_default_instance_;
class RTypePack;
class RTypePackDefaultTypeInternal;
extern RTypePackDefaultTypeInternal _RTypePack_default_instance_;
class ResponsePacket;
class ResponsePacketDefaultTypeInternal;
extern ResponsePacketDefaultTypeInternal _ResponsePacket_default_instance_;
}  // namespace RType
PROTOBUF_NAMESPACE_OPEN
template<> ::RType::LobbyPacket* Arena::CreateMaybeMessage<::RType::LobbyPacket>(Arena*);
template<> ::RType::RTypePack* Arena::CreateMaybeMessage<::RType::RTypePack>(Arena*);
template<> ::RType::ResponsePacket* Arena::CreateMaybeMessage<::RType::ResponsePacket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RType {

enum RTypePack_PackType : int {
  RTypePack_PackType_RESPONSE = 0,
  RTypePack_PackType_CREATE_ROOM = 1,
  RTypePack_PackType_JOIN_ROOM = 2,
  RTypePack_PackType_LEAVE_ROOM = 3,
  RTypePack_PackType_START_GAME = 4,
  RTypePack_PackType_ROOM_CREATED = 5,
  RTypePack_PackType_ROOM_JOINED = 6,
  RTypePack_PackType_ROOM_PLAYER_JOINED = 7,
  RTypePack_PackType_ROOM_IS_FULL = 8,
  RTypePack_PackType_ROOM_LEFT = 9,
  RTypePack_PackType_ROOM_PLAYER_LEFT = 10,
  RTypePack_PackType_TRYING = 100,
  RTypePack_PackType_OK = 200,
  RTypePack_PackType_NOTFOUND = 404,
  RTypePack_PackType_RTypePack_PackType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RTypePack_PackType_RTypePack_PackType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RTypePack_PackType_IsValid(int value);
constexpr RTypePack_PackType RTypePack_PackType_PackType_MIN = RTypePack_PackType_RESPONSE;
constexpr RTypePack_PackType RTypePack_PackType_PackType_MAX = RTypePack_PackType_NOTFOUND;
constexpr int RTypePack_PackType_PackType_ARRAYSIZE = RTypePack_PackType_PackType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RTypePack_PackType_descriptor();
template<typename T>
inline const std::string& RTypePack_PackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RTypePack_PackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RTypePack_PackType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RTypePack_PackType_descriptor(), enum_t_value);
}
inline bool RTypePack_PackType_Parse(
    const std::string& name, RTypePack_PackType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RTypePack_PackType>(
    RTypePack_PackType_descriptor(), name, value);
}
enum ResponsePacket_ActionType : int {
  ResponsePacket_ActionType_OK = 0,
  ResponsePacket_ActionType_BAD = 1,
  ResponsePacket_ActionType_ResponsePacket_ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponsePacket_ActionType_ResponsePacket_ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponsePacket_ActionType_IsValid(int value);
constexpr ResponsePacket_ActionType ResponsePacket_ActionType_ActionType_MIN = ResponsePacket_ActionType_OK;
constexpr ResponsePacket_ActionType ResponsePacket_ActionType_ActionType_MAX = ResponsePacket_ActionType_BAD;
constexpr int ResponsePacket_ActionType_ActionType_ARRAYSIZE = ResponsePacket_ActionType_ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponsePacket_ActionType_descriptor();
template<typename T>
inline const std::string& ResponsePacket_ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponsePacket_ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponsePacket_ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponsePacket_ActionType_descriptor(), enum_t_value);
}
inline bool ResponsePacket_ActionType_Parse(
    const std::string& name, ResponsePacket_ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponsePacket_ActionType>(
    ResponsePacket_ActionType_descriptor(), name, value);
}
// ===================================================================

class RTYPECOMMON_API RTypePack :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RType.RTypePack) */ {
 public:
  RTypePack();
  virtual ~RTypePack();

  RTypePack(const RTypePack& from);
  RTypePack(RTypePack&& from) noexcept
    : RTypePack() {
    *this = ::std::move(from);
  }

  inline RTypePack& operator=(const RTypePack& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTypePack& operator=(RTypePack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RTypePack& default_instance();

  enum PacketCase {
    kResponseContent = 4,
    kLobbyContent = 5,
    PACKET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RTypePack* internal_default_instance() {
    return reinterpret_cast<const RTypePack*>(
               &_RTypePack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RTypePack& a, RTypePack& b) {
    a.Swap(&b);
  }
  inline void Swap(RTypePack* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RTypePack* New() const final {
    return CreateMaybeMessage<RTypePack>(nullptr);
  }

  RTypePack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RTypePack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RTypePack& from);
  void MergeFrom(const RTypePack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTypePack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RType.RTypePack";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RTypePack_2eproto);
    return ::descriptor_table_RTypePack_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RTypePack_PackType PackType;
  static constexpr PackType RESPONSE =
    RTypePack_PackType_RESPONSE;
  static constexpr PackType CREATE_ROOM =
    RTypePack_PackType_CREATE_ROOM;
  static constexpr PackType JOIN_ROOM =
    RTypePack_PackType_JOIN_ROOM;
  static constexpr PackType LEAVE_ROOM =
    RTypePack_PackType_LEAVE_ROOM;
  static constexpr PackType START_GAME =
    RTypePack_PackType_START_GAME;
  static constexpr PackType ROOM_CREATED =
    RTypePack_PackType_ROOM_CREATED;
  static constexpr PackType ROOM_JOINED =
    RTypePack_PackType_ROOM_JOINED;
  static constexpr PackType ROOM_PLAYER_JOINED =
    RTypePack_PackType_ROOM_PLAYER_JOINED;
  static constexpr PackType ROOM_IS_FULL =
    RTypePack_PackType_ROOM_IS_FULL;
  static constexpr PackType ROOM_LEFT =
    RTypePack_PackType_ROOM_LEFT;
  static constexpr PackType ROOM_PLAYER_LEFT =
    RTypePack_PackType_ROOM_PLAYER_LEFT;
  static constexpr PackType TRYING =
    RTypePack_PackType_TRYING;
  static constexpr PackType OK =
    RTypePack_PackType_OK;
  static constexpr PackType NOTFOUND =
    RTypePack_PackType_NOTFOUND;
  static inline bool PackType_IsValid(int value) {
    return RTypePack_PackType_IsValid(value);
  }
  static constexpr PackType PackType_MIN =
    RTypePack_PackType_PackType_MIN;
  static constexpr PackType PackType_MAX =
    RTypePack_PackType_PackType_MAX;
  static constexpr int PackType_ARRAYSIZE =
    RTypePack_PackType_PackType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PackType_descriptor() {
    return RTypePack_PackType_descriptor();
  }
  template<typename T>
  static inline const std::string& PackType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PackType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PackType_Name.");
    return RTypePack_PackType_Name(enum_t_value);
  }
  static inline bool PackType_Parse(const std::string& name,
      PackType* value) {
    return RTypePack_PackType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientipFieldNumber = 2,
    kCodeFieldNumber = 1,
    kClientIdFieldNumber = 3,
    kResponseContentFieldNumber = 4,
    kLobbyContentFieldNumber = 5,
  };
  // string clientip = 2;
  void clear_clientip();
  const std::string& clientip() const;
  void set_clientip(const std::string& value);
  void set_clientip(std::string&& value);
  void set_clientip(const char* value);
  void set_clientip(const char* value, size_t size);
  std::string* mutable_clientip();
  std::string* release_clientip();
  void set_allocated_clientip(std::string* clientip);
  private:
  const std::string& _internal_clientip() const;
  void _internal_set_clientip(const std::string& value);
  std::string* _internal_mutable_clientip();
  public:

  // .RType.RTypePack.PackType code = 1;
  void clear_code();
  ::RType::RTypePack_PackType code() const;
  void set_code(::RType::RTypePack_PackType value);
  private:
  ::RType::RTypePack_PackType _internal_code() const;
  void _internal_set_code(::RType::RTypePack_PackType value);
  public:

  // uint32 clientId = 3;
  void clear_clientid();
  ::PROTOBUF_NAMESPACE_ID::uint32 clientid() const;
  void set_clientid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_clientid() const;
  void _internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .RType.ResponsePacket ResponseContent = 4;
  bool has_responsecontent() const;
  private:
  bool _internal_has_responsecontent() const;
  public:
  void clear_responsecontent();
  const ::RType::ResponsePacket& responsecontent() const;
  ::RType::ResponsePacket* release_responsecontent();
  ::RType::ResponsePacket* mutable_responsecontent();
  void set_allocated_responsecontent(::RType::ResponsePacket* responsecontent);
  private:
  const ::RType::ResponsePacket& _internal_responsecontent() const;
  ::RType::ResponsePacket* _internal_mutable_responsecontent();
  public:

  // .RType.LobbyPacket LobbyContent = 5;
  bool has_lobbycontent() const;
  private:
  bool _internal_has_lobbycontent() const;
  public:
  void clear_lobbycontent();
  const ::RType::LobbyPacket& lobbycontent() const;
  ::RType::LobbyPacket* release_lobbycontent();
  ::RType::LobbyPacket* mutable_lobbycontent();
  void set_allocated_lobbycontent(::RType::LobbyPacket* lobbycontent);
  private:
  const ::RType::LobbyPacket& _internal_lobbycontent() const;
  ::RType::LobbyPacket* _internal_mutable_lobbycontent();
  public:

  void clear_Packet();
  PacketCase Packet_case() const;
  // @@protoc_insertion_point(class_scope:RType.RTypePack)
 private:
  class _Internal;
  void set_has_responsecontent();
  void set_has_lobbycontent();

  inline bool has_Packet() const;
  inline void clear_has_Packet();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientip_;
  int code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 clientid_;
  union PacketUnion {
    PacketUnion() {}
    ::RType::ResponsePacket* responsecontent_;
    ::RType::LobbyPacket* lobbycontent_;
  } Packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_RTypePack_2eproto;
};
// -------------------------------------------------------------------

class RTYPECOMMON_API ResponsePacket :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RType.ResponsePacket) */ {
 public:
  ResponsePacket();
  virtual ~ResponsePacket();

  ResponsePacket(const ResponsePacket& from);
  ResponsePacket(ResponsePacket&& from) noexcept
    : ResponsePacket() {
    *this = ::std::move(from);
  }

  inline ResponsePacket& operator=(const ResponsePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponsePacket& operator=(ResponsePacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponsePacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponsePacket* internal_default_instance() {
    return reinterpret_cast<const ResponsePacket*>(
               &_ResponsePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResponsePacket& a, ResponsePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponsePacket* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponsePacket* New() const final {
    return CreateMaybeMessage<ResponsePacket>(nullptr);
  }

  ResponsePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponsePacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponsePacket& from);
  void MergeFrom(const ResponsePacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RType.ResponsePacket";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RTypePack_2eproto);
    return ::descriptor_table_RTypePack_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponsePacket_ActionType ActionType;
  static constexpr ActionType OK =
    ResponsePacket_ActionType_OK;
  static constexpr ActionType BAD =
    ResponsePacket_ActionType_BAD;
  static inline bool ActionType_IsValid(int value) {
    return ResponsePacket_ActionType_IsValid(value);
  }
  static constexpr ActionType ActionType_MIN =
    ResponsePacket_ActionType_ActionType_MIN;
  static constexpr ActionType ActionType_MAX =
    ResponsePacket_ActionType_ActionType_MAX;
  static constexpr int ActionType_ARRAYSIZE =
    ResponsePacket_ActionType_ActionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ActionType_descriptor() {
    return ResponsePacket_ActionType_descriptor();
  }
  template<typename T>
  static inline const std::string& ActionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActionType_Name.");
    return ResponsePacket_ActionType_Name(enum_t_value);
  }
  static inline bool ActionType_Parse(const std::string& name,
      ActionType* value) {
    return ResponsePacket_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string Content = 2;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .RType.ResponsePacket.ActionType Code = 1;
  void clear_code();
  ::RType::ResponsePacket_ActionType code() const;
  void set_code(::RType::ResponsePacket_ActionType value);
  private:
  ::RType::ResponsePacket_ActionType _internal_code() const;
  void _internal_set_code(::RType::ResponsePacket_ActionType value);
  public:

  // @@protoc_insertion_point(class_scope:RType.ResponsePacket)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RTypePack_2eproto;
};
// -------------------------------------------------------------------

class RTYPECOMMON_API LobbyPacket :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RType.LobbyPacket) */ {
 public:
  LobbyPacket();
  virtual ~LobbyPacket();

  LobbyPacket(const LobbyPacket& from);
  LobbyPacket(LobbyPacket&& from) noexcept
    : LobbyPacket() {
    *this = ::std::move(from);
  }

  inline LobbyPacket& operator=(const LobbyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyPacket& operator=(LobbyPacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LobbyPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LobbyPacket* internal_default_instance() {
    return reinterpret_cast<const LobbyPacket*>(
               &_LobbyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LobbyPacket& a, LobbyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyPacket* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LobbyPacket* New() const final {
    return CreateMaybeMessage<LobbyPacket>(nullptr);
  }

  LobbyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LobbyPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LobbyPacket& from);
  void MergeFrom(const LobbyPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RType.LobbyPacket";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RTypePack_2eproto);
    return ::descriptor_table_RTypePack_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIDFieldNumber = 2,
    kUdpIpFieldNumber = 4,
    kPlayerIDFieldNumber = 1,
    kMaxPlayerFieldNumber = 3,
    kPortFieldNumber = 5,
  };
  // string RoomID = 2;
  void clear_roomid();
  const std::string& roomid() const;
  void set_roomid(const std::string& value);
  void set_roomid(std::string&& value);
  void set_roomid(const char* value);
  void set_roomid(const char* value, size_t size);
  std::string* mutable_roomid();
  std::string* release_roomid();
  void set_allocated_roomid(std::string* roomid);
  private:
  const std::string& _internal_roomid() const;
  void _internal_set_roomid(const std::string& value);
  std::string* _internal_mutable_roomid();
  public:

  // string udp_ip = 4;
  void clear_udp_ip();
  const std::string& udp_ip() const;
  void set_udp_ip(const std::string& value);
  void set_udp_ip(std::string&& value);
  void set_udp_ip(const char* value);
  void set_udp_ip(const char* value, size_t size);
  std::string* mutable_udp_ip();
  std::string* release_udp_ip();
  void set_allocated_udp_ip(std::string* udp_ip);
  private:
  const std::string& _internal_udp_ip() const;
  void _internal_set_udp_ip(const std::string& value);
  std::string* _internal_mutable_udp_ip();
  public:

  // uint32 PlayerID = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::uint32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 MaxPlayer = 3;
  void clear_maxplayer();
  ::PROTOBUF_NAMESPACE_ID::uint32 maxplayer() const;
  void set_maxplayer(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_maxplayer() const;
  void _internal_set_maxplayer(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 port = 5;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:RType.LobbyPacket)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr udp_ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 playerid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 maxplayer_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RTypePack_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RTypePack

// .RType.RTypePack.PackType code = 1;
inline void RTypePack::clear_code() {
  code_ = 0;
}
inline ::RType::RTypePack_PackType RTypePack::_internal_code() const {
  return static_cast< ::RType::RTypePack_PackType >(code_);
}
inline ::RType::RTypePack_PackType RTypePack::code() const {
  // @@protoc_insertion_point(field_get:RType.RTypePack.code)
  return _internal_code();
}
inline void RTypePack::_internal_set_code(::RType::RTypePack_PackType value) {
  
  code_ = value;
}
inline void RTypePack::set_code(::RType::RTypePack_PackType value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:RType.RTypePack.code)
}

// string clientip = 2;
inline void RTypePack::clear_clientip() {
  clientip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RTypePack::clientip() const {
  // @@protoc_insertion_point(field_get:RType.RTypePack.clientip)
  return _internal_clientip();
}
inline void RTypePack::set_clientip(const std::string& value) {
  _internal_set_clientip(value);
  // @@protoc_insertion_point(field_set:RType.RTypePack.clientip)
}
inline std::string* RTypePack::mutable_clientip() {
  // @@protoc_insertion_point(field_mutable:RType.RTypePack.clientip)
  return _internal_mutable_clientip();
}
inline const std::string& RTypePack::_internal_clientip() const {
  return clientip_.GetNoArena();
}
inline void RTypePack::_internal_set_clientip(const std::string& value) {
  
  clientip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RTypePack::set_clientip(std::string&& value) {
  
  clientip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RType.RTypePack.clientip)
}
inline void RTypePack::set_clientip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clientip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RType.RTypePack.clientip)
}
inline void RTypePack::set_clientip(const char* value, size_t size) {
  
  clientip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RType.RTypePack.clientip)
}
inline std::string* RTypePack::_internal_mutable_clientip() {
  
  return clientip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RTypePack::release_clientip() {
  // @@protoc_insertion_point(field_release:RType.RTypePack.clientip)
  
  return clientip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RTypePack::set_allocated_clientip(std::string* clientip) {
  if (clientip != nullptr) {
    
  } else {
    
  }
  clientip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientip);
  // @@protoc_insertion_point(field_set_allocated:RType.RTypePack.clientip)
}

// uint32 clientId = 3;
inline void RTypePack::clear_clientid() {
  clientid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RTypePack::_internal_clientid() const {
  return clientid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RTypePack::clientid() const {
  // @@protoc_insertion_point(field_get:RType.RTypePack.clientId)
  return _internal_clientid();
}
inline void RTypePack::_internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  clientid_ = value;
}
inline void RTypePack::set_clientid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:RType.RTypePack.clientId)
}

// .RType.ResponsePacket ResponseContent = 4;
inline bool RTypePack::_internal_has_responsecontent() const {
  return Packet_case() == kResponseContent;
}
inline bool RTypePack::has_responsecontent() const {
  return _internal_has_responsecontent();
}
inline void RTypePack::set_has_responsecontent() {
  _oneof_case_[0] = kResponseContent;
}
inline void RTypePack::clear_responsecontent() {
  if (_internal_has_responsecontent()) {
    delete Packet_.responsecontent_;
    clear_has_Packet();
  }
}
inline ::RType::ResponsePacket* RTypePack::release_responsecontent() {
  // @@protoc_insertion_point(field_release:RType.RTypePack.ResponseContent)
  if (_internal_has_responsecontent()) {
    clear_has_Packet();
      ::RType::ResponsePacket* temp = Packet_.responsecontent_;
    Packet_.responsecontent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RType::ResponsePacket& RTypePack::_internal_responsecontent() const {
  return _internal_has_responsecontent()
      ? *Packet_.responsecontent_
      : *reinterpret_cast< ::RType::ResponsePacket*>(&::RType::_ResponsePacket_default_instance_);
}
inline const ::RType::ResponsePacket& RTypePack::responsecontent() const {
  // @@protoc_insertion_point(field_get:RType.RTypePack.ResponseContent)
  return _internal_responsecontent();
}
inline ::RType::ResponsePacket* RTypePack::_internal_mutable_responsecontent() {
  if (!_internal_has_responsecontent()) {
    clear_Packet();
    set_has_responsecontent();
    Packet_.responsecontent_ = CreateMaybeMessage< ::RType::ResponsePacket >(
        GetArenaNoVirtual());
  }
  return Packet_.responsecontent_;
}
inline ::RType::ResponsePacket* RTypePack::mutable_responsecontent() {
  // @@protoc_insertion_point(field_mutable:RType.RTypePack.ResponseContent)
  return _internal_mutable_responsecontent();
}

// .RType.LobbyPacket LobbyContent = 5;
inline bool RTypePack::_internal_has_lobbycontent() const {
  return Packet_case() == kLobbyContent;
}
inline bool RTypePack::has_lobbycontent() const {
  return _internal_has_lobbycontent();
}
inline void RTypePack::set_has_lobbycontent() {
  _oneof_case_[0] = kLobbyContent;
}
inline void RTypePack::clear_lobbycontent() {
  if (_internal_has_lobbycontent()) {
    delete Packet_.lobbycontent_;
    clear_has_Packet();
  }
}
inline ::RType::LobbyPacket* RTypePack::release_lobbycontent() {
  // @@protoc_insertion_point(field_release:RType.RTypePack.LobbyContent)
  if (_internal_has_lobbycontent()) {
    clear_has_Packet();
      ::RType::LobbyPacket* temp = Packet_.lobbycontent_;
    Packet_.lobbycontent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RType::LobbyPacket& RTypePack::_internal_lobbycontent() const {
  return _internal_has_lobbycontent()
      ? *Packet_.lobbycontent_
      : *reinterpret_cast< ::RType::LobbyPacket*>(&::RType::_LobbyPacket_default_instance_);
}
inline const ::RType::LobbyPacket& RTypePack::lobbycontent() const {
  // @@protoc_insertion_point(field_get:RType.RTypePack.LobbyContent)
  return _internal_lobbycontent();
}
inline ::RType::LobbyPacket* RTypePack::_internal_mutable_lobbycontent() {
  if (!_internal_has_lobbycontent()) {
    clear_Packet();
    set_has_lobbycontent();
    Packet_.lobbycontent_ = CreateMaybeMessage< ::RType::LobbyPacket >(
        GetArenaNoVirtual());
  }
  return Packet_.lobbycontent_;
}
inline ::RType::LobbyPacket* RTypePack::mutable_lobbycontent() {
  // @@protoc_insertion_point(field_mutable:RType.RTypePack.LobbyContent)
  return _internal_mutable_lobbycontent();
}

inline bool RTypePack::has_Packet() const {
  return Packet_case() != PACKET_NOT_SET;
}
inline void RTypePack::clear_has_Packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline RTypePack::PacketCase RTypePack::Packet_case() const {
  return RTypePack::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponsePacket

// .RType.ResponsePacket.ActionType Code = 1;
inline void ResponsePacket::clear_code() {
  code_ = 0;
}
inline ::RType::ResponsePacket_ActionType ResponsePacket::_internal_code() const {
  return static_cast< ::RType::ResponsePacket_ActionType >(code_);
}
inline ::RType::ResponsePacket_ActionType ResponsePacket::code() const {
  // @@protoc_insertion_point(field_get:RType.ResponsePacket.Code)
  return _internal_code();
}
inline void ResponsePacket::_internal_set_code(::RType::ResponsePacket_ActionType value) {
  
  code_ = value;
}
inline void ResponsePacket::set_code(::RType::ResponsePacket_ActionType value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:RType.ResponsePacket.Code)
}

// string Content = 2;
inline void ResponsePacket::clear_content() {
  content_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResponsePacket::content() const {
  // @@protoc_insertion_point(field_get:RType.ResponsePacket.Content)
  return _internal_content();
}
inline void ResponsePacket::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:RType.ResponsePacket.Content)
}
inline std::string* ResponsePacket::mutable_content() {
  // @@protoc_insertion_point(field_mutable:RType.ResponsePacket.Content)
  return _internal_mutable_content();
}
inline const std::string& ResponsePacket::_internal_content() const {
  return content_.GetNoArena();
}
inline void ResponsePacket::_internal_set_content(const std::string& value) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponsePacket::set_content(std::string&& value) {
  
  content_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RType.ResponsePacket.Content)
}
inline void ResponsePacket::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RType.ResponsePacket.Content)
}
inline void ResponsePacket::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RType.ResponsePacket.Content)
}
inline std::string* ResponsePacket::_internal_mutable_content() {
  
  return content_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponsePacket::release_content() {
  // @@protoc_insertion_point(field_release:RType.ResponsePacket.Content)
  
  return content_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePacket::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:RType.ResponsePacket.Content)
}

// -------------------------------------------------------------------

// LobbyPacket

// uint32 PlayerID = 1;
inline void LobbyPacket::clear_playerid() {
  playerid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LobbyPacket::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LobbyPacket::playerid() const {
  // @@protoc_insertion_point(field_get:RType.LobbyPacket.PlayerID)
  return _internal_playerid();
}
inline void LobbyPacket::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  playerid_ = value;
}
inline void LobbyPacket::set_playerid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:RType.LobbyPacket.PlayerID)
}

// string RoomID = 2;
inline void LobbyPacket::clear_roomid() {
  roomid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LobbyPacket::roomid() const {
  // @@protoc_insertion_point(field_get:RType.LobbyPacket.RoomID)
  return _internal_roomid();
}
inline void LobbyPacket::set_roomid(const std::string& value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RType.LobbyPacket.RoomID)
}
inline std::string* LobbyPacket::mutable_roomid() {
  // @@protoc_insertion_point(field_mutable:RType.LobbyPacket.RoomID)
  return _internal_mutable_roomid();
}
inline const std::string& LobbyPacket::_internal_roomid() const {
  return roomid_.GetNoArena();
}
inline void LobbyPacket::_internal_set_roomid(const std::string& value) {
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LobbyPacket::set_roomid(std::string&& value) {
  
  roomid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RType.LobbyPacket.RoomID)
}
inline void LobbyPacket::set_roomid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RType.LobbyPacket.RoomID)
}
inline void LobbyPacket::set_roomid(const char* value, size_t size) {
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RType.LobbyPacket.RoomID)
}
inline std::string* LobbyPacket::_internal_mutable_roomid() {
  
  return roomid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LobbyPacket::release_roomid() {
  // @@protoc_insertion_point(field_release:RType.LobbyPacket.RoomID)
  
  return roomid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LobbyPacket::set_allocated_roomid(std::string* roomid) {
  if (roomid != nullptr) {
    
  } else {
    
  }
  roomid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomid);
  // @@protoc_insertion_point(field_set_allocated:RType.LobbyPacket.RoomID)
}

// uint32 MaxPlayer = 3;
inline void LobbyPacket::clear_maxplayer() {
  maxplayer_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LobbyPacket::_internal_maxplayer() const {
  return maxplayer_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LobbyPacket::maxplayer() const {
  // @@protoc_insertion_point(field_get:RType.LobbyPacket.MaxPlayer)
  return _internal_maxplayer();
}
inline void LobbyPacket::_internal_set_maxplayer(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  maxplayer_ = value;
}
inline void LobbyPacket::set_maxplayer(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_maxplayer(value);
  // @@protoc_insertion_point(field_set:RType.LobbyPacket.MaxPlayer)
}

// string udp_ip = 4;
inline void LobbyPacket::clear_udp_ip() {
  udp_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LobbyPacket::udp_ip() const {
  // @@protoc_insertion_point(field_get:RType.LobbyPacket.udp_ip)
  return _internal_udp_ip();
}
inline void LobbyPacket::set_udp_ip(const std::string& value) {
  _internal_set_udp_ip(value);
  // @@protoc_insertion_point(field_set:RType.LobbyPacket.udp_ip)
}
inline std::string* LobbyPacket::mutable_udp_ip() {
  // @@protoc_insertion_point(field_mutable:RType.LobbyPacket.udp_ip)
  return _internal_mutable_udp_ip();
}
inline const std::string& LobbyPacket::_internal_udp_ip() const {
  return udp_ip_.GetNoArena();
}
inline void LobbyPacket::_internal_set_udp_ip(const std::string& value) {
  
  udp_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LobbyPacket::set_udp_ip(std::string&& value) {
  
  udp_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RType.LobbyPacket.udp_ip)
}
inline void LobbyPacket::set_udp_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  udp_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RType.LobbyPacket.udp_ip)
}
inline void LobbyPacket::set_udp_ip(const char* value, size_t size) {
  
  udp_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RType.LobbyPacket.udp_ip)
}
inline std::string* LobbyPacket::_internal_mutable_udp_ip() {
  
  return udp_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LobbyPacket::release_udp_ip() {
  // @@protoc_insertion_point(field_release:RType.LobbyPacket.udp_ip)
  
  return udp_ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LobbyPacket::set_allocated_udp_ip(std::string* udp_ip) {
  if (udp_ip != nullptr) {
    
  } else {
    
  }
  udp_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), udp_ip);
  // @@protoc_insertion_point(field_set_allocated:RType.LobbyPacket.udp_ip)
}

// uint32 port = 5;
inline void LobbyPacket::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LobbyPacket::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LobbyPacket::port() const {
  // @@protoc_insertion_point(field_get:RType.LobbyPacket.port)
  return _internal_port();
}
inline void LobbyPacket::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void LobbyPacket::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:RType.LobbyPacket.port)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RType

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RType::RTypePack_PackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RType::RTypePack_PackType>() {
  return ::RType::RTypePack_PackType_descriptor();
}
template <> struct is_proto_enum< ::RType::ResponsePacket_ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RType::ResponsePacket_ActionType>() {
  return ::RType::ResponsePacket_ActionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_RTypePack_2eproto
